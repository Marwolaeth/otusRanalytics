library(shiny) 
install.packages ( 'rsconnect')
install.packages ('UScensus2010')
library(rsconnect)
library(UScensus2010)
runExample("01_hello")
# "Number of bins:" регулирует ширину бинов хистограммы

#  ui.R (user interface, UI) управляет расположением элементов управления и внешним видом приложения.
# server.R содержит инструкции, необходимые, чтобы создать ваше приложение и управлять его поведением.
# Взято из MVC (Model-View-Controller) в PHP

getwd()
setwd("/home/df/OTUS/shiny")

#################################################################################
#################################################################################
#################################################################################

# 1. регимся на сайте https://www.shinyapps.io/
# STEP 1 – INSTALL RSCONNECT
# бесплатно доступно 5 приложений и 25 рабочих часов

# 2. Выполняем в консоли rstulio  код из окна под строкой "STEP 2 – AUTHORIZE ACCOUNT". 
# Копируем кнопкой ("Copy to clipboard"), а не мышкой. Токен не отображается. видимо чтобы не показывать посторонним. 
# 
# 3. "STEP 3 – DEPLOY"  Заливаем приложение
rsconnect::deployApp('path/to/your/app')


#################################################################################
# редктируем файл ui.R, запускаем
#################################################################################

#runApp("dreissena_app")
runApp("apps/app1/")



#  назначение файла server.R состоит в том, чтобы описать правила взаимодействий между входными и выходными параметрами.
# Входные данные хранятся в объекте input, выходные - в объекте output.
# Для обновления выводимой на экран информации в реальном времени используются т.н. "реактивные" функции 
# (т.е., функции, мгновенно реагирующие на выполненные пользователем изменения тех или иных параметров).


# file "server.R"
# интерактивность приложения возникает благодаря использованию функций reactiveText() и reactivePlot(), 
# которые отслеживают текущий выбор пользователя и производят обновление соответствующих переменных при изменении выбора


# замените заголовок с "Hello Shiny!" на "Hello World!"
# установите минимальное значение полозка равным 5
# поменяйте цвет гистограммы с "darkgray" на "skyblue"

### запуск приложения кнопкой, либо "Ctrl+Shift+Enter"

system.file("examples", package="shiny")

runExample("01_hello") # a histogram
runExample("02_text") # tables and data frames
runExample("03_reactivity") # a reactive expression
runExample("04_mpg") # global variables
runExample("05_sliders") # slider bars
runExample("06_tabsets") # tabbed panels
runExample("07_widgets") # help text and submit buttons
runExample("08_html") # Shiny app built from HTML
runExample("09_upload") # file upload wizard
runExample("10_download") # file download wizard
runExample("11_timer") # an automated timer


# https://shiny.rstudio.com/gallery/
browseURL("https://shiny.rstudio.com/gallery/")


###########  2 ###########################
#откроем файлы server.R и ui.R и удалим из них всё лишнее, чтобы остались только следующие строки:
### ui.R
# shinyUI(fluidPage(
# ))

### server.R
# shinyServer(function(input, output) {
# })

# Результатом его выполнения будет ничего не умеющее приложение 
# с пустым интерфейсом пользователя. Оно и станет отправной точкой.


# ui.R использует функцию fluidPage для создания макета окна, которое автоматически подстраивается 
# под окно браузера пользователя. Все остальные функции вашего приложения нужно размещать внутри fluidPage.

runApp("apps/app2")
file.edit("apps/app2/ui.R")

# Боковая панель приложения по умолчанию размещается слева, но вы можете перенести направо, указав аргумент 
# position = "right".

runApp("apps/app2.1")
file.edit("apps/app2.1/ui.R")

# можно использовать navbarPage, чтобы создать многостраничный интерфейс,включающий 
# панель навигации (navigation bar). Или можно использовать функции fluidRow и column для создания макета с сеткой.



### HTML-содержимое
# Имена функций соответствуют именам тегов HTML5:

#  p  	  <p>  	   A paragraph of text
#  h1  	  `        A first level header
#  h2  	  <h2>	   A second level header
#  h3  	  <h3>	   A third level header
#  h4 	  <h4>  	 A fourth level header
#  h5 	  <h5>	   A fifth level header
#  h6	    <h6>  	 A sixth level header
#  a	    <a>	     A hyper link
#  br	    <br>	   A line break (e.g. a blank line)
#  div	  <div>  	 A division of text with a uniform style
#  span	  <span>	 An in-line division of text with a uniform style
#  pre	  <pre>	   Text ‘as is’ in a fixed width font
#  code	  <code>	 A formatted block of code
#  img	  <img> 	 An image
#  strong	<strong> Bold text
#  em 	  <em>	   Italicized text
#  HTML		         Directly passes a character string as HTML code

### Заголовки (app2.2)
# Чтобы создать заголовок нужно:  выбрать функцию заголовка (например, h1 или h5);
# передать ей текст заголовка.
# h1("Мой заголовок")

# скрипт использует шесть уровней заголовков in main 


runApp("apps/app2.2")
file.edit("apps/app2.2/ui.R")


# align = "center" для выравнивания по центру (app2.3)

runApp("apps/app2.3")
file.edit("apps/app2.3/ui.R")


### Форматирование текста
runApp("apps/app2.4")
file.edit("apps/app2.4/ui.R")

### Изображения 

# Для размещения файлов изображений в приложениях Shiny существует функция img(src = "file.png")
# функция img передаёт его в соответствующий HTML-элемент
# вы можете задать высоту (height) и ширину (width) изображения 
# img(src = "my_image.png", height = 72, width = 72)

# Функция img предполагает, что файл изображения хранится в папке с именем www внутри каталога приложения.
# Вообще, в папку www складывается всё, что нужно Shiny для создания веб-интерфейса приложения: изображения,
# каскадные таблицы стилей и т. п.


runApp("apps/app2.5")
file.edit("apps/app2.5/ui.R")
dir("apps/app2.5/www")


### Probe

runApp("apps/app2.6")
file.edit("apps/app2.6/ui.R")
dir("apps/app2.6/www")

# повторим разметку из перевого примера

runApp("apps/app1")
file.edit("apps/app1/ui.R")
file.edit("apps/app1/server.R")

#################################################################################
### 3. Виджеты Shiny 
#################################################################################

# В отличии от "показательно-информационных" элементов прошлого раздела, 
# виджеты предназначены для передачи действий пользователя

# Чтобы добавить виджет в приложение, поместите функцию, отвечающую за создание виджета, 
# внутрь sidebarPanel или mainPanel в файле ui.R

# Первые два аргумента для любого виджета это:
# **имя виджета**. Пользователь его не увидит, но имя можно использовать для доступа 
# к значению (value) виджета. Имя должно быть текстовой строкой;
# **метка**. Метка (label) появится в приложении вместе с виджетом. Это должна быть 
# текстовая строка,которая может быть пустой ("").
# В следующем примере имя виджета — "action", а метка — "Action":
  
#  actionButton("action", label = "Action")


runApp("apps/app3.1")
file.edit("apps/app3.1/ui.R")


# Самостоятельная работа
# Перепишите ui.R для получения результата:

runApp("apps/app3.2")
file.edit("apps/app3.2/ui.R")

#################################################################################
### 4. приложения, реагирующие на действия пользователя
#################################################################################


# файл server.R - это аналог контроллера в  MVC

# Задать реакцию приложения можно в два шага:

# 1) добавить объект R в пользовательский интерфейс ui.R;
# 2) в файле server.R рассказать Shiny о том, как построить объект. Объект будет "реактивным",
# если его код обращается к значению виджета.


### Шаг 1: добавляем объект R в UI

# Shiny предоставляет семейство функций, которые превращают объекты R в выводы интерфейса пользователя:

#  Функция вывода 	      создаёт
----------------------------------- 
# htmlOutput	            raw HTML
# uiOutput	              raw HTML
# imageOutput	            image
# plotOutput	            plot
# tableOutput	            table
# textOutput	            text
# verbatimTextOutput	    text
  
# Вы можете добавить функцию вывода в пользовательский интерфейс тем же способом, что HTML-элементы и виджеты.
# Разместите функцию вывода в боковой панели (sidebarPanel) или главной панели (mainPanel) в файле ui.R.  
  
### Шаг 1: добавляем объект R в UI
# используется textOutput, чтобы вывести строку текста на главную панель приложения:

runApp("apps/app4.1")
file.edit("apps/app4.1/ui.R") 

### Шаг 2: запишите код, чтобы создать объект  
# Теперь нужно объяснить Shiny как этот объект создать.
# Сделайте это, вставив в файл server.R R код, который создаёт объект  
# Код должен помещаться в безымянной функции, которая находится внутри shinyServer в скрипте server.R.

# Безымянная функция играет особую роль в работе Shiny: она строит спископодобный объект с именем output,
# который содержит весь код, необходимый для обновления объектов R в приложении. Каждый объект R должен
# иметь свою собственную запись в этом списке.


file.edit("apps/app4.1/server.R") 
runApp("apps/app4.1")

# main >>> "You have selected this"


# Каждая запись в output должна содержать вывод одной из функций Shiny из семейства render*. 
# Эти функции захватывают выражение R и выполняют его предварительную обработку. Используйте 
# функцию render*, которая соответствует типу используемого вами реактивного объекта.


#  render*-функция	  создаёт
#  ----------------------------------------------------------
#  renderImage		    images (saved as a link to a source file)
#  renderPlot	    	  plots
#  renderPrint	    	any printed output
#  renderTable	    	data frame, matrix, other table like structures
#  renderText	    	  character strings
#  renderUI		    	  a Shiny tag object or HTML



# Каждая функция семейства *render принимает единственный аргумент: выражение R, окруженное фигурными скобками — {}.
# Выражение может состоять всего из одной строки или же из многих строк кода, как если бы это был вызов сложной функции.

# Чтобы  это всё заработало, ваше выражение должно возвращать объект, который вы собираетесь выводить 
# (фрагмент текста, график, набор данных и т. п.). Если выражение не возвращает объект, 
# или возвращает неправильный тип объекта, вы получите сообщение об ошибке. 


### Использование значений виджета

# приложение Shiny отобразит на главной панели: "You have selected this". Однако этот текст не будет "реактивным"

file.edit("apps/app4.1/server.R") 

# безымянная функция содержит два аргумента — input и output
# output — это спископодобный объект, который хранит инструкции для создания объектов R в вашем приложении.
# input — это второй спископодобный объект. Он хранит текущие значения всех виджетов в вашем приложении. 
# Эти значения будут сохранены под именами, которые вы дали виджетам в ui.R.


# например, наше приложение содержит два виджета: один называется "Var", второй — "range"
# Значения "Var" и "range" будут сохранены в input как input$var и input$range. Поскольку виджет ползунка (slider) 
# содержит две переменные (минимум и максимум), input$range будет содержать вектор длины 2

########
# Shiny автоматически сделает объект реактивным, если тот использует значение из input

file.edit("apps/app4.2/server.R") 
runApp("apps/app4.2")

### Запускаем приложение и следим за реакциями

runApp("apps/app4.2", display.mode = "showcase")


# Добавим вторую строку реактивного текста в главную панель вашего Shiny-приложения. Эта строка  содержит
# "You have chosen a range that goes from something to something", и каждое something  показываeт
# текущее минимальное (min) и максимальное (max) значение полозка.

file.edit("apps/app4.3/ui.R") 
file.edit("apps/app4.3/server.R") 

runApp("apps/app4.3", display.mode = "showcase")



#################################################################################
### 5. Используем скрипты R и файлы данных
#################################################################################


# мы создадим  приложение, отображающее данные переписи населения в США (US Census).

# counties.rds — это набор (dataset) демографических данных по каждому округу США,

getwd()
counties <- readRDS("apps/app5.1/data/counties.rds")
head(counties)

# counties.rds включает в себя:

#  имя (name) каждого округа (county) в США;
#  общую численность населения округа (total.pop);
#  процент жителей округа, являющихся белыми (white), чёрными (black), латиноамериканцами (hispanic) или азиатами (asian).



# helpers.R — это скрипт на R, который поможет вам создать фоновую картограмму (или хороплет, по англ.: choropleth map)
# Фоновая картограмма — это карта, данные на которую наносятся при помощи окраски разной степени насыщенности.
# В нашем случае helpers.R создаёт percent_map — функцию, отображающую на карте данные из counties.rds
# helpers.R использует пакеты R maps и mapproj.
install.packages(c("maps", "mapproj"))



file.edit("apps/app5.1/helpers.R")

# Функция percent_map из helpers.R принимает на вход пять аргументов:
  
# Аргумент	     	Значение
# ___________________________________________________________
# var     	     	вектор-столбец из набора данных counties.rds
# color   	     	строка, задающая название цвета (см. функцию colors())
# legend.title	  строка заголовка подписи к легенде на графике
# max	     	     	максимальное значение насыщенности (по умолчанию, 100)
# min	     	     	минимальное значение насыщенности (по умолчанию, 0)


# Чтобы построить картограмму по данным округов, вы можете запустить percent_map в командной строке:

library(maps)
library(mapproj)
source("apps/app5.1/helpers.R")
counties <- readRDS("apps/app5.1/data/counties.rds")
percent_map(counties$white, "darkgreen", "% white")


# Чтобы использовать percent_map, мы сначала запускаем helpers.R с помощью функции source, 
# а затем загружаем counties.rds функцией readRDS. Кроме того, мы загружаем библиотеки 
# library(maps) и library(mapproj) а затем загружаем counties.rds функцией readRDS. 

# Чтобы использовать percent_map в вашем приложении нужно, чтобы Shiny вызвал те же самые функции,
# но с другими значениями аргументов. 

# Когда Shiny выполняет команды из скрипта server.R, он трактует все пути к файлам так,
# словно бы они все начинаются от каталога, в котором находится server.R

# Так как вы сохранили helpers.R в том же каталоге, что и server.R, то указать Shiny загрузить его можно командой
source("helpers.R")

# загрузить counties.rds можно так:
counties <- readRDS("data/counties.rds")

# Shiny выполнит все команды, если вы поместите их в скрипт server.R. Но то, как часто будет
# выполняться команда зависит от места в скрипте, куда вы её поместите. Соотвественно, расположение
# команды скажется на производительности вашего приложения.

# Как только пользователь изменит состояние виджета, Shiny перезапустит команды на языке R,
# описывающие поведение объекта, который отвечает за реакцию виджета.

# скрипт server.R выполняется один раз, когда вы запускаете ваше приложение;
# безымянная функция внутри shinyServer запускается один раз за каждое посещение пользователем вашего приложения;
# команды R внутри функций render* выполняются много раз. Shiny запускает их всякий раз,
# как только пользователь изменяет виджет.

### То есть:
# Скрипты с источниками функций (загружаемые с помощью source), загрузка библиотек 
# и чтение наборов данных должны помещаться в начале файла server.R, вне функции shinyServer.
# Shiny запустит этот код всего один раз — ровно столько, сколько нужно для настройки
# параметров вашего сервера, позволяющих выполнить команды R, которые  находятся внутри shinyServer.

### Определять пользовательские объекты нужно внутри безымянной функции из shinyServer, но за пределами вызовов функций render*. 

### Внутри функций render* должен размещаться только код, который Shiny будет выполнять всякий раз, чтобы заново перестроить объект. 


file.edit("apps/app5.1/server.R")
file.edit("apps/app5.1/ui.R")

runApp("apps/app5.1", display.mode = "showcase")
runApp("apps/app5.1")


# Приложение censusVis содержит один реактивный объект — график с именем "map". 
# Этот график строится с помощью функции percent_map, которая принимает пять аргументов:

# три первых аргумента, var, color и legend.title зависят от значения, выбранного в виджете-списке;
# последние два аргумента, max и min, должны быть равны максимальному (max) и минимальному (min) значениям виджета-ползунка.

# Скрипт server.R, приведенный ниже, показывает один из способов передачи "реактивных" аргументов
# в percent_map. R-функция switch может преобразовать вывод из списка в нужные вам значения. 



#################################################################################
### 6. как оптимизировать приложения Shiny, содержащие реактивные выражения.
#################################################################################

install.packages("quantmod")
library(quantmod)

# Приложение stockVis ищет цены на акции по тикерам и отображает результаты в виде графика. Приложение позволяет:
# выбрать акцию для наблюдения;
# указать диапазон времени наблюдения;
# выбрать, указывать ли по оси Y цену на акцию или логарифм цены;
# задать, следует ли корректировать цены с учетом инфляции.

runApp("apps/stockVis")

# флажок (check box) "Adjust prices for inflation" пока не работает


# По умолчанию stockVis отображает тикер SPY соответствующий индексу S&P 500. 
# Чтобы найти котировки других акций, введите символ акции, принятый в Yahoo! Finance. 
#  список подобных символов:

browseURL("ftp://ftp.nasdaqtrader.com/symboldirectory/nasdaqlisted.txt")
browseURL("ftp://ftp.nasdaqtrader.com/symboldirectory/otherlisted.txt")

# Некоторые популярные символы: GOOG (Google), AAPL (Apple) и GS (Goldman Sachs).

# StockVis также зависит от скрипта helpers.R, содержащего функцию, которая вносит в цены на акции поправку на инфляцию

# В приложении stockVis используется несколько новых виджетов:
# селектор диапазона данных (date range selector), созданный с помощью функции dateRangeInput, 
# и пара флажков checkboxInput. Флажки устроены просто: они возвращают TRUE, если флажок включен,
# и FALSE, если флажок не установлен. В скрипте ui.R эти флажки названы log и adjust.
# Это означает, что вы можете просмотреть их значения input$log и input$adjust в скрипте server.R


file.edit("apps/stockVis/server.R")
file.edit("apps/stockVis/ui.R")



# В приложении stockVis есть проблема.
# при нажатии "Plot y axis on the log scale": значение input$log изменится, 
# в результате будут заново пересчитаны все команды внутри renderPlot:

output$plot <- renderPlot({
  data <- getSymbols(input$symb, src = "yahoo", 
                     from = input$dates[1],
                     to = input$dates[2],
                     auto.assign = FALSE)
  
  chartSeries(data, theme = chartTheme("white"), 
              type = "line", log.scale = input$log, TA = NULL)
})

# Каждый раз при выполнении renderPlot:
# 1) он заново получает данные от Yahoo! Finance с помощью getSymbols, и
# 2) он перерисовывает график с нужным видом оси.

# Yahoo! Finance может заблокировать доступ, если ваше приложение будет слишком часто
# к нему обращаться (потому что оно будет выглядеть как бот). 
# Но главное: повторный вызов getSymbols — это лишнее действие, оно может замедлить работу приложения.

### Реактивные выражения 
### Реактивное выражение — это выражение на R, которое использует входные данные виджета и возвращает значение. 

# Реактивное выражение будет обновлять это значение всякий раз, когда изменяется значение виджета.
# Для создания реактивных выражений используется функция reactive()


## реактивное выражение, использующее виджеты stockVis для выборки данных из Yahoo:
dataInput <- reactive({
  getSymbols(input$symb, src = "yahoo", 
             from = input$dates[1],
             to = input$dates[2],
             auto.assign = FALSE)
})


# При выполнении dataInput будет вызываться getSymbols и возвращать результаты в виде таблицы 
# с данными о ценах. Вы можете построить график ценовых данных, вызывая dataInput в renderPlot:

output$plot <- renderPlot({    
  chartSeries(dataInput(), theme = chartTheme("white"), 
              type = "line", log.scale = input$log, TA = NULL)
})


# Реактивные выражения устроены немного "умнее" обычных функций R. 
# Они кэшируют свои значения и знают, когда их те устаревают. 
# При первом запуске реактивного выражения, оно сохранит результат выполнения
# в памяти компьютера. В следующий раз, когда вы вызовете реактивное выражение, 
# оно может вернуть этот сохранённый результат, не делая никаких вычислений.

# Реактивное выражение будет возвращать сохранённый результат до тех пор, 
# пока этот результат остаётся актуальным. 


file.edit("apps/stockVis2/server.R")
runApp("apps/stockVis2")


# При нажатии "Plot y axis on the log scale", изменяется input$log, 
# что вызывает запуск renderPlot. Сейчас renderPlot вызывает dataInput();
# dataInput проверяет, не изменились ли виджеты dates и symb;
# dataInput возвращает сохранённый им ранее набор данных с ценами на акции,
# не скачивая заново данные из Yahoo!
# renderPlot построит новый график с заданным пользователем видом оси координат.


