---
title: "hw_3_1: Работа с API для получения данных"
author: "Андрей"
output: html_document
---

В данном домашнем задании Вам будет предложено потренироваться в основах работы с API различных источников информации. В задании мы будем использовать следующие ресурсы: FRED, Quandl, quantmod и VK API. Для FRED и VK понадобится отдельная процедура авторизации - для FRED достаточно просто зарегистироваться, для VK ссылки на инструкции - в 3 пункте.

Для повторяющихся операций имеет смысл использовать методы функционального программирования.

При возникновении вопросов напишите преподавателю в чат.

# Необходимые пакеты

```{r message=FALSE}
required_packages <- c(
  'fredr',
  'Quandl',
  'vkR',
  'igraph',
  'tidyverse',
  'data.table'
)
if (!all(required_packages %in% installed.packages())) {
  install.packages(setdiff(required_packages, installed.packages()))
}
library(fredr)
library(Quandl)
library(vkR)
library(igraph)
library(tidyverse) # содержит и dplyr и purrr
library(data.table)
```

Пакеты, при необходимости, можно добавить.

# 1

Получите ключ API для FRED (нужно пройти регистрацию). Данные ключа в коде можно не приводить. Достаточно сохранить его в переменной `.MY_FRED_API_KEY`, так как ключ даёт доступ к данным, но не меняет сами данные.

```{r echo=FALSE}
.MY_FRED_API_KEY <- ''
fredr_set_key(.MY_FRED_API_KEY)
```

Загрузить данные по следующим кодам и сохранить их в **один** список:

```{r include=TRUE}
data_codes <- c("RUSCPIALLAINMEI",
                "CCUSMA02RUA618N",
                "LMUNRRTTRUA156N",
                "LFAC74TTRUA647S")

series_list <- map(data_codes, fredr)
str(series_list)
```

Для данных кодов, выведите полное название набора данных, к которому они относятся.

```{r}
map(data_codes, fredr_series_search_id) %>%
  map_chr('title') %>%
  cbind(data_codes, .) %>%
  knitr::kable(col.names = c('id', 'title'), format = 'pandoc')
```

Проверьте класс данных, который возвращает функция-загрузчик. Выведите количество наблюдений в каждом наборе данных. Выведите первую и последнюю строки каждого набора данных. 

```{r}
map(series_list, class)
map(series_list, nrow)
map(series_list, filter, row_number() %in% c(1, n()))
# map(series_list, ~ as.data.table(.)[c(1, .N)])
```

Соединить данные в единый `tibble` при помощи функций `reduce()` из пакета `purrr` и `inner_join()` из `dplyr`. (Вложенные функции)

```{r}
russia <- reduce(series_list, inner_join, by = 'date')
head(russia, 10) # Названия переменных ужас
```

В полученном наборе данных присвоить колонкам со значениями (имеют `value` в имени) имена кодов. Оставить в таблице только колонки значений и даты. (подсказка - пакет `tidyverse` подключает и `stringr`)

```{r}
names(russia)[str_detect(names(russia), 'value')] <- data_codes
# Это наверняка можно сделать в tidyverse, но я не знаю, как (
russia <- russia[, c('date', data_codes)]
knitr::kable(head(russia, 10), format = 'pandoc')
```

Выведите `summary()` для полученного набора.

```{r}
summary(russia)
```

Постройте матрицу корреляции для **числовых** данных. Также выведите `heatmap()` по корреляции. Выставите параметры `cexRow` и `cexCol` на 0.5, чтобы график помещался на лист при верстке html документа.

```{r}
(series_cor <- cor(russia[, data_codes]))
heatmap(series_cor, cexRow = .5, cexCol = .5, symm = TRUE)
```

Между какими переменными наблюдается самая высокая и самая низкая корреляция? (значения по диагонали - игнорировать)

*Все числовые переменные в наборе данных демонстрируют между собой корреляцию от средней до очень высокой. Так, очень высокая корреляция отмечается между курсом доллара `CCUSMA02RUA618N` и Индексом потребительских цен `RUSCPIALLAINMEI` (0,91) и между ИПЦ и численностью экономически активного населения^1^ (0,86). Самые низкие (и заодно отрицательные) коэффициенты корреляции —между ИПЦ и уровнем зарегистрированной безработицы (-0,56) и между уровнем зарегистрированной безработицы и ИПЦ (-0,58%).*

^1^Интересно, почему.

# 2

В данном задании скачивать данные будем с Quandl. Замечу, что Quandl позволяет сделать 50 анонимных запросов в сутки, для большего количества нужно зарегистрировать бесплатный аккаунт.

## 2.1

С помощью функции `Quandl.search()` выберите любой набор данных, который Вам понравится. Будет лучше, если данные в нём - помесячные. Соедините коды базы данных и набора данных (формат: **"DB_code/DSet_code"**) и загрузите его в переменную.

```{r echo=FALSE}
Quandl.api_key("") # Удалить перед сдачей
```

```{r}
srch <- Quandl.search('sentiment', per_page = 25, silent = TRUE)
head(srch, 10)

# United States - Consumer Sentiment
consent_code <- filter(
  srch,
  str_detect(tolower(name), 'consumer sent'),
  !premium
) %>%
  unite(., 'dset_code', database_code, dataset_code, sep = '/') %>%
  pull(dset_code)
consent <- Quandl(consent_code, start_date = '1975-01-01')
class(consent)
dim(consent)
str(consent)
head(consent, 10)
```

Выведите график по Вашему набору данных через `plot()`. Добавьте подписи осей.

```{r}
plot(consent,
     type = 'l',
     lwd = 2,
     col = 'blue',
     main = sprintf(
       'US Consumer Sentiment Index,\n(%s—%s)',
       min(year(consent$Date)),
       max(year(consent$Date))
    )
)
```

Кратко опишите график.

*На графике отображается изменение по месяцам Индекса потребительского настроения (потребительской уверенности) в США по данным Мичиганского университета в 1975—2019 гг. Из графика видно, что Индекс принимал максимальные значения на рубеже 1990-х и 2000-х годов и падал до минимальных значений в начале 1980-х годов и в кризис 2008—2009 гг. При этом Индекс никогда не опускался ниже 50 пунктов.*

## 2.2

С помощью функции `getAnywhere()` покопайтесь во внутреннем коде функции `Quandl()`. Найдите конечную функцию, которая обращается к API Quandl (понадобится покопаться в функциях, вызываемых в других функциях, то есть `Quandl()` содержит в себе вложенные функции обращения к API). Какая функция записывает результат в переменную `response`? В каком пакете она содержится?

```{r eval=FALSE}
body(Quandl)
# Quandl() → Quandl.dataset.get()
Quandl::Quandl.dataset.get
# Quandl() → Quandl.dataset.get() → quandl.api()
Quandl::quandl.api
getAnywhere('VERB')
getAnywhere('quandl.api.build_request')
# Quandl() → Quandl.dataset.get() → quandl.api() →
# httr::VERB() → quandl.api.build_request()
```

*Функция `Quandl()` вызывает функцию `Quandl.dataset.get()`, а затем обрабатывает полученные данные в соответствии со своими аргументами. `Quandl.dataset.get()` получает на вход код набора данных Quandl и обрабатывает датафрейм — результат вызова `quandl.api()`, которой подает путь к набору данных на сайте Quandl и дополнительный параметры. `quandl.api()` формирует запрос к серверу Quandl с помощью скрытой функции `quandl.api.build_request()`, отправляет его с помощью `httr::VERB()`, преобразует ответ из JSON в датафрейм и возвращает в `Quandl.dataset.get()`*.

* На занятии мы столкнулись со случаем, когда функция, вызываемая в функции пакета (на занятии это была функция из пакета fredr), не может быть вызвана нами самостоятельно. В этом случае функция, на самом деле, по-прежнему существует, просто находится в другом окружении. Такие "тайно запрятанные" функции можно найти через `Quandl:::FUNC_NAME()`.

Для своего запроса попробуйте вывести текст `request`, который идёт на сервер Quandl. Для этого Вам нужно найти функцию, генерирующую этот запрос, понять, какие данные она принимает на вход и проверить эту функцию на своих данных ввода. (Подсказка - функция скрытая)

```{r}
request <- Quandl:::quandl.api.build_request(
  paste('datasets', consent_code, sep = '/'),
  start_date = '1975-01-01'
)
# Воспроизводим работу Quandl::quandl.api()
response <- httr::GET(
  request$request_url,
  config = do.call(httr::add_headers, request$headers),
  query = request$params
)
data <- jsonlite::fromJSON(
  httr::content(response, as = 'text'),
  simplifyVector = TRUE
)
str(data, 1)
str(data, 2)           # Вышестоящая функция обрабатывает именно список "dataset"
str(data$dataset$data) # Набор данных возвращаются в виде символьной матрицы
```

# 3

В финальном упражнении мы поработаем с VK API. Для работы с API VK понадобится (на всё это уйдет минут 10):

* Создать свой сайт (одну страничку) на github: [Ссылка](https://htmlacademy.ru/blog/useful/programming/github-as-hosting) (Шаг 4 повторять не обязательно)

* Подключиться к VK API: создать свое приложение. В данной инструкции:
[Ссылка](https://selesnow.github.io/rvkstat/##Форма-для-получения-токена-доступа-пользователя-по-схеме-implict-flow) автор создает сайт, хотя можно сделать Standalone-приложение. Остальные шаги те же: включить open API, добавить сайт, который Вы только что завели на github, скопировать ID приложения.

По ID приложения через фукнцию `vkOAUTH()` в R Вас выведет в окно браузера. В адресной строке будет большая строка, часть из нее - токен. Его нужно скопировать и передать в `setAccessToken()`.

Так как в данном сегменте задания используется токен, являющийся конфиденциальной информацией, данный пункт я рекомендую: 

* перенести номер в отдельный rmd файл, 

* сверстать из него html документ, 

* заархивировать и в таком виде отправить на проверку (html страницу). 

Код можно продублировать и в этом решении, только в параметрах чанка указать `eval = FALSE` (пример ниже через блок кода).

После сдачи дз приложение можно удалить - токен больше не будет активен (вообще он активен в течение 1 суток).

```{r echo=FALSE, eval=FALSE}
.MY_VK_OAUTH <- 5573604
# vkOAuth(.MY_VK_OAUTH)

.MY_VK_TOKEN <- 'f02eb6a388440c1bbc59e51bdfee1299d677b468ac53d7f8abfa02d281d25db2515fd892e6b4e311e0291'
setAccessToken(access_token = .MY_VK_TOKEN)
```

Задание:

* Получить список друзей
* Для каждого друга получить список пабликов, на которые он(а) подписаны. (функция `getGroups()`, для самих групп нужно выбрать $items). Так как у некоторых друзей паблики скрыты настройками приватности, VK API выдаст ошибку при попытке получить паблики данных пользователей. Для этого нужно "поймать ошибку", чтобы код продолжал работать. В целом это отдельная большая тема, поэтому вот готовая функция поиска групп для 1 пользователя, обернутая в `map()`:

```{r}
friends_df <- getFriends(fields = 'sex,bdate')$items

friends_groups <- map(friends_df$id, 
    function(x) {tryCatch(getGroups(user_id = x, extended = 1)$items$name,
           error = function(e) {NULL})})
# str(friends_groups, 1)
```

* Сделать агрегирующую таблицу (паблик - сколько друзей подписано)
* Взять топ 10-15 пабликов и вывести по ним `barplot()`

```{r}
friends_groups_tab <- table(do.call(c, friends_groups))
friends_groups_tab <- sort(friends_groups_tab, decreasing = TRUE)[1:15]
knitr::kable(friends_groups_tab) # Ничего удивительного

par(mar = c(0, 8, 1, 1))
top15 <- barplot(
  rev(friends_groups_tab),
  horiz = TRUE,
  main  = 'ТОП-15 сообществ',
  axes  = FALSE,
  col   = '#ff0038',
  width = .7,
  space = .3,
  las   = 2,
  cex.names = .7
)
text(x = 1, y = top15, labels = rev(friends_groups_tab), col = '#ffffff')
```

___

Критерии оценивания:

 * Домашняя работа сдана (1 балл)
 * Решена 1 задача (1 балл)
 * Решена 2 задача (2 балла)
 * Решена 3 задача (3 балла)
 * Код оформлен согласно рекомендациям tidyverse (использован `purrr`) (1 балл)
 * Задание сдано до рекомендуемого дедлайна (1 балл)
 * Задание сдано с 1 попытки (1 балл)
 
Задание считается выполненным, если набирается 6 баллов
