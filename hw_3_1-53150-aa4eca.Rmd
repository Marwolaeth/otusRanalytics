---
title: "hw_3_1: Работа с API для получения данных"
author: "Андрей"
output: html_document
---

В данном домашнем задании Вам будет предложено потренироваться в основах работы с API различных источников информации. В задании мы будем использовать следующие ресурсы: FRED, Quandl, quantmod и VK API. Для FRED и VK понадобится отдельная процедура авторизации - для FRED достаточно просто зарегистироваться, для VK ссылки на инструкции - в 3 пункте.

Для повторяющихся операций имеет смысл использовать методы функционального программирования.

При возникновении вопросов напишите преподавателю в чат.

# Необходимые пакеты

```{r message=FALSE}
required_packages <- c(
  'fredr',
  'Quandl',
  'vkR',
  'igraph',
  'tidyverse',
  'data.table'
)
if (!all(required_packages %in% installed.packages())) {
  install.packages(setdiff(required_packages, installed.packages()))
}
library(fredr)
library(Quandl)
library(vkR)
library(igraph)
library(tidyverse) # содержит и dplyr и purrr
library(data.table)
```

Пакеты, при необходимости, можно добавить.

# 1

Получите ключ API для FRED (нужно пройти регистрацию). Данные ключа в коде можно не приводить. Достаточно сохранить его в переменной `.MY_FRED_API_KEY`, так как ключ даёт доступ к данным, но не меняет сами данные.

```{r include=TRUE}
.MY_FRED_API_KEY <- '6aecc8cb992cf159eedbe813fe18f274'
fredr_set_key(.MY_FRED_API_KEY)
```

Загрузить данные по следующим кодам и сохранить их в **один** список:

```{r include=TRUE}
data_codes <- c("RUSCPIALLAINMEI",
                "CCUSMA02RUA618N",
                "LMUNRRTTRUA156N",
                "LFAC74TTRUA647S")

series_list <- map(data_codes, fredr)
str(series_list)
```

Для данных кодов, выведите полное название набора данных, к которому они относятся.

```{r}
map(data_codes, fredr_series_search_id) %>%
  map_chr('title') %>%
  cbind(data_codes, .) %>%
  knitr::kable(col.names = c('id', 'title'), format = 'pandoc')
```

Проверьте класс данных, который возвращает функция-загрузчик. Выведите количество наблюдений в каждом наборе данных. Выведите первую и последнюю строки каждого набора данных. 

```{r}
map(series_list, class)
map(series_list, nrow)
map(series_list, filter, row_number() %in% c(1, n()))
# map(series_list, ~ as.data.table(.)[c(1, .N)])
```

Соединить данные в единый `tibble` при помощи функций `reduce()` из пакета `purrr` и `inner_join()` из `dplyr`. (Вложенные функции)

```{r}
russia <- reduce(series_list, inner_join, by = 'date')
head(russia, 10)
# Названия переменных ужас
```

В полученном наборе данных присвоить колонкам со значениями (имеют `value` в имени) имена кодов. Оставить в таблице только колонки значений и даты. (подсказка - пакет `tidyverse` подключает и `stringr`)

```{r}
names(russia)[str_detect(names(russia), 'value')] <- data_codes
# Это наверняка можно сделать в tidyverse, но я не знаю, как (
russia <- russia[, c('date', data_codes)]
knitr::kable(head(russia, 10), format = 'pandoc')
```

Выведите `summary()` для полученного набора.

```{r}
summary(russia)
```

Постройте матрицу корреляции для **числовых** данных. Также выведите `heatmap()` по корреляции. Выставите параметры `cexRow` и `cexCol` на 0.5, чтобы график помещался на лист при верстке html документа.

```{r}
(series_cor <- cor(russia[, data_codes]))
heatmap(series_cor, cexRow = .5, cexCol = .5, symm = TRUE)
```

Между какими переменными наблюдается самая высокая и самая низкая корреляция? (значения по диагонали - игнорировать)



# 2

В данном задании скачивать данные будем с Quandl. Замечу, что Quandl позволяет сделать 50 анонимных запросов в сутки, для большего количества нужно зарегистрировать бесплатный аккаунт.

## 2.1

С помощью функции `Quandl.search()` выберите любой набор данных, который Вам понравится. Будет лучше, если данные в нём - помесячные. Соедините коды базы данных и набора данных (формат: **"DB_code/DSet_code"**) и загрузите его в переменную.

```{r}
Quandl.api_key("") # Удалить перед сдачей
# Ваш код
```

Выведите график по Вашему набору данных через `plot()`. Добавьте подписи осей.

```{r}
# Ваш код
```

Кратко опишите график.

## 2.2

С помощью функции `getAnywhere()` покопайтесь во внутреннем коде функции `Quandl()`. Найдите конечную функцию, которая обращается к API Quandl (понадобится покопаться в функциях, вызываемых в других функциях, то есть `Quandl()` содержит в себе вложенные функции обращения к API). Какая функция записывает результат в переменную `response`? В каком пакете она содержится?

```{r}
# Ваш код
```

* На занятии мы столкнулись со случаем, когда функция, вызываемая в функции пакета (на занятии это была функция из пакета fredr), не может быть вызвана нами самостоятельно. В этом случае функция, на самом деле, по-прежнему существует, просто находится в другом окружении. Такие "тайно запрятанные" функции можно найти через `Quandl:::FUNC_NAME()`.

Для своего запроса попробуйте вывести текст `request`, который идёт на сервер Quandl. Для этого Вам нужно найти функцию, генерирующую этот запрос, понять, какие данные она принимает на вход и проверить эту функцию на своих данных ввода. (Подсказка - функция скрытая)

```{r}
# Ваш код
```

# 3

В финальном упражнении мы поработаем с VK API. Для работы с API VK понадобится (на всё это уйдет минут 10):

* Создать свой сайт (одну страничку) на github: [Ссылка](https://htmlacademy.ru/blog/useful/programming/github-as-hosting) (Шаг 4 повторять не обязательно)

* Подключиться к VK API: создать свое приложение. В данной инструкции:
[Ссылка](https://selesnow.github.io/rvkstat/##Форма-для-получения-токена-доступа-пользователя-по-схеме-implict-flow) автор создает сайт, хотя можно сделать Standalone-приложение. Остальные шаги те же: включить open API, добавить сайт, который Вы только что завели на github, скопировать ID приложения.

По ID приложения через фукнцию `vkOAUTH()` в R Вас выведет в окно браузера. В адресной строке будет большая строка, часть из нее - токен. Его нужно скопировать и передать в `setAccessToken()`.

Так как в данном сегменте задания используется токен, являющийся конфиденциальной информацией, данный пункт я рекомендую: 

* перенести номер в отдельный rmd файл, 

* сверстать из него html документ, 

* заархивировать и в таком виде отправить на проверку (html страницу). 

Код можно продублировать и в этом решении, только в параметрах чанка указать `eval = FALSE` (пример ниже через блок кода).

После сдачи дз приложение можно удалить - токен больше не будет активен (вообще он активен в течение 1 суток).

```{r}
# .MY_VK_OAUTH <- "ID приложения"
# vkOAuth(.MY_VK_OAUTH)

# .MY_VK_TOKEN <- "Ваш токен"
# setAccessToken(access_token = .MY_VK_TOKEN)
```

Задание:

* Получить список друзей
* Для каждого друга получить список пабликов, на которые он(а) подписаны. (функция `getGroups()`, для самих групп нужно выбрать $items). Так как у некоторых друзей паблики скрыты настройками приватности, VK API выдаст ошибку при попытке получить паблики данных пользователей. Для этого нужно "поймать ошибку", чтобы код продолжал работать. В целом это отдельная большая тема, поэтому вот готовая функция поиска групп для 1 пользователя, обернутая в `map()`:

```{r eval=FALSE}
friends_groups <- map(friends_df$id, 
    function(x) {tryCatch(getGroups(user_id = x, extended = 1)$items$name,
           error = function(e) {NULL})})
```

* Сделать агрегирующую таблицу (паблик - сколько друзей подписано)
* Взять топ 10-15 пабликов и вывести по ним `barplot()`

```{r}
# Ваш код
```

___

Критерии оценивания:

 * Домашняя работа сдана (1 балл)
 * Решена 1 задача (1 балл)
 * Решена 2 задача (2 балла)
 * Решена 3 задача (3 балла)
 * Код оформлен согласно рекомендациям tidyverse (использован `purrr`) (1 балл)
 * Задание сдано до рекомендуемого дедлайна (1 балл)
 * Задание сдано с 1 попытки (1 балл)
 
Задание считается выполненным, если набирается 6 баллов
